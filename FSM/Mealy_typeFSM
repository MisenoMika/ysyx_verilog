module top_module (
    input clk,
    input aresetn,    // Asynchronous active-low reset
    input x,
    output reg z ); 
    parameter ONE = 2'b00, ONE_ZERO = 2'b01, IDLE = 2'b10;
    reg [1:0] state, next_state;

    always@(*)begin
        z = 0;
        case(state)
            IDLE: begin
                if(x) begin
                    next_state = ONE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            ONE: begin
                if(x == 0) begin
                    next_state = ONE_ZERO;
                end
                else begin
                    next_state = ONE;
                end
            end
            ONE_ZERO: begin
                if(x) begin
                    next_state = ONE;
                    z = 1;
                end
                else begin
                    next_state = IDLE;
                end
            end
            default: next_state = IDLE;
        endcase
    end

    always@(posedge clk or negedge aresetn) begin
        if (!aresetn) begin
            state <= IDLE;
        end 
        else begin
            state <= next_state;
        end
    end

endmodule

//以下为参考答案
module top_module_ (
	input clk,
	input aresetn,
	input x,
	output reg z
);

	// Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	parameter S=0, S1=1, S10=2;
	reg[1:0] state, next;		// Make sure state and next are big enough to hold the state encodings.
	
	
	
	// Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.			
	always@(posedge clk, negedge aresetn)
		if (!aresetn)
			state <= S;
		else
			state <= next;
			
	

    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should be next state be?
    // Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			S: next = x ? S1 : S;
			S1: next = x ? S1 : S10;
			S10: next = x ? S1 : S;
			default: next = 'x;
		endcase
	end
	
	
	
	// Combinational output logic. I used a combinational always block.
	// In a Mealy state machine, the output depends on the current state *and*
	// the inputs.
	always@(*) begin
		case (state)
			S: z = 0;
			S1: z = 0;
			S10: z = x;		// This is a Mealy state machine: The output can depend (combinational) on the input.
			default: z = 1'bx;
		endcase
	end
	
endmodule

