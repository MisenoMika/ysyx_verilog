module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    parameter IDLE = 2'b00, WRONG = 2'b01, DATA= 2'b10, DONE = 2'b11;
    reg [1:0] state, next_state; 
    reg [7:0] data;
    reg [31:0] count;
    wire odd;
    wire parity_reset;
    always@(*) begin
        case(state)
            IDLE: begin
                if(in == 0) begin
                    next_state = DATA;
                end
                else begin
                    next_state = IDLE;
                end
            end
            WRONG: begin
                if(in == 1)begin
                    next_state = IDLE;
                end
                else next_state = WRONG;
            end
            DATA: begin
                if (count < 10)begin 
                    next_state = DATA;
                end
                else begin
                    if (in) begin
                        if (odd)
                            next_state = DONE;
                        else
                            next_state = IDLE;
                    end
                    else
                        next_state = WRONG;
                end
            end
            DONE: begin
                if(in == 0) begin
                    next_state = DATA;
                end
                else begin
                    next_state = IDLE;
                end
            end
            default: next_state = IDLE;
        endcase
    end
    
    parity p1(.clk(clk), .reset(parity_reset), .in(in), .odd(odd) );   
    
    always@(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            count <= 0;
            data <= 0;
        end 
        else begin
            state <= next_state;
            if(next_state == DATA) begin
                count <= count + 1'd1;//è®¡æ•°é€»è¾‘ä¸€å®šè¦èƒ½å¤Ÿåæ˜ é¢˜ç›®è¦æ±‚ï¼Œå³è®¡æˆ‘ä»¬éœ€è¦æ•°çš„ä¸€å…±11ä½æ•°å­—ï¼Œ
                //æœ¬æ¥å†™çš„æ¡ä»¶æ˜¯if(state == data)ï¼Œä½†è¿™æ ·ä¼šæœ‰æ—¶åºé”™è¯¯ï¼ˆåœ¨ç»„åˆé€»è¾‘åˆ¤æ–­å‡ºå³å°†è·³å‡ºæ—¶countä»ç„¶é”™è¯¯æ‰§è¡Œ+1ï¼‰
            end
            else begin
                count <= 0;
            end
            if(next_state == DATA && count <= 8) begin
                data[count-1] <= in;
            end
        end
    end

    assign done = (state == DONE);
    assign out_byte = (state == DONE)? data : 8'b0;
    assign parity_reset = !(state == DATA);
endmodule

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;
endmodule

module top_module_(
    input clk,
    input in,
    input reset,
    output [7:0] out_byte,
    output done
);

    parameter IDLE  = 2'b00,
              DATA  = 2'b01,
              DONE  = 2'b10,
              WRONG = 2'b11;

    reg [1:0] state, next_state;
    reg [3:0] count;        // ç­‰ä»·äºåŸæ¥çš„ cnt
    reg [7:0] data;

    wire odd;
    wire parity_reset;

    /*-------------------------
     * çŠ¶æ€å¯„å­˜å™¨
     *-------------------------*/
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    /*-------------------------
     * çŠ¶æ€è½¬ç§»ï¼ˆå®Œå…¨ç­‰ä»·ï¼‰
     *-------------------------*/
    always @(*) begin
        case (state)
            IDLE: begin
                if (in)
                    next_state = IDLE;
                else
                    next_state = DATA;
            end

            DATA: begin
                if (count > 0)
                    next_state = DATA;
                else begin
                    if (in) begin
                        if (odd)
                            next_state = DONE;
                        else
                            next_state = IDLE;
                    end
                    else
                        next_state = WRONG;
                end
            end

            DONE: begin
                if (in)
                    next_state = IDLE;
                else
                    next_state = DATA;
            end

            WRONG: begin
                if (in)
                    next_state = IDLE;
                else
                    next_state = WRONG;
            end

            default: next_state = IDLE;
        endcase
    end

    /*-------------------------
     * è®¡æ•°å™¨ï¼ˆå€’è®¡æ•°ï¼Œå®Œå…¨ä¸€è‡´ï¼‰
     *-------------------------*/
    always @(posedge clk) begin
        if (reset)
            count <= 4'd10;
        else begin
            if (next_state == IDLE || next_state == DONE)
                count <= 4'd10;
            else if (next_state == DATA)
                count <= count - 1'b1;
        end
    end

    /*-------------------------
     * æ•°æ®æ¥æ”¶ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
     *-------------------------*/
    always @(posedge clk) begin
        if (reset)
            data <= 8'b0;
        else if (next_state == DATA && count <= 9 && count >= 2)
            data[9 - count] <= in;
    end

    /*-------------------------
     * å¥‡å¶æ ¡éªŒï¼ˆåŸæ ·ç­‰ä»·ï¼‰
     *-------------------------*/
    assign parity_reset = !(state == DATA);

    parity p0 (
        .clk   (clk),
        .reset (parity_reset),
        .in    (in),
        .odd   (odd)
    );

    /*-------------------------
     * è¾“å‡º
     *-------------------------*/
    assign done     = (state == DONE);
    assign out_byte = data;

endmodule

/*
è¿™æ˜¯ä¸€ä¸ª**éå¸¸å¥½çš„åé—®**ï¼Œè€Œä¸”è¯´æ˜ä½ å·²ç»åœ¨â€œåè¯â€è®¾è®¡äº† ğŸ‘
ä½ çš„ç›´è§‰æ˜¯**åˆç†çš„ï¼Œä½†ä¸å®Œæ•´**ã€‚æˆ‘ä»¬æŠŠè¿™ä»¶äº‹**æ‹†åˆ°æ—¶é’Ÿæ²¿çº§åˆ«**ï¼Œä½ ä¼šçœ‹åˆ°ï¼š

> **state çœ‹èµ·æ¥å·²ç»è·³å‡º DATAï¼Œä½† count çš„â€œå‰¯ä½œç”¨â€å·²ç»å‘ç”Ÿäº†ï¼Œè€Œä¸”è¿™ä¸ªå‰¯ä½œç”¨ä¼šå½±å“åç»­åˆ¤æ–­ã€‚**

---

## ä¸€ã€å…ˆç›´æ¥å›ç­”ä½ è¿™å¥è¯

> **â€œstate ä¸æ˜¯å·²ç»è·³å‡º DATA äº†å—ï¼Œcount çš„å¤§å°ä¸å½±å“å…¶ä»–çŠ¶æ€â€**

âŒ **ä¸å®Œå…¨æ­£ç¡®**

æ­£ç¡®è¯´æ³•åº”è¯¥æ˜¯ï¼š

> **state åœ¨â€œé€»è¾‘ä¸Šâ€å·²ç»å†³å®šè¦è·³å‡º DATAï¼Œ
> ä½†åœ¨è¿™ä¸ªæ—¶é’Ÿæ²¿ï¼Œcount çš„æ›´æ–°ä»ç„¶ä¼šè¢«æ‰§è¡Œï¼Œ
> è€Œè¿™ä¸ªæ›´æ–°ä¼šå½±å“åç»­è‹¥å¹²æ‹çš„è¡Œä¸ºã€‚**

---

## äºŒã€å…³é”®è¯¯åŒºï¼šä½ æŠŠâ€œå†³å®šè·³è½¬â€å’Œâ€œå®Œæˆè·³è½¬â€å½“æˆä¸€ä»¶äº‹äº†

åœ¨åŒæ­¥ FSM é‡Œï¼Œè¿™ä¸¤ä»¶äº‹æ˜¯**åˆ†å¼€çš„**ï¼š

| é˜¶æ®µ                  | å‘ç”Ÿæ—¶é—´                      |
| ------------------- | ------------------------- |
| è®¡ç®— next_state       | **æ—¶é’Ÿæ²¿ä¹‹å‰ï¼ˆç»„åˆé€»è¾‘ï¼‰**           |
| state <= next_state | **æ—¶é’Ÿæ²¿**                   |
| count <= â€¦          | **åŒä¸€ä¸ªæ—¶é’Ÿæ²¿**                |
| æ–° state ç”Ÿæ•ˆ          | **ä¸‹ä¸€ä¸ª delta cycle / ä¸‹ä¸€æ‹** |

ğŸ‘‰ **stateã€count æ˜¯â€œåŒæ—¶æ›´æ–°â€çš„**

---

## ä¸‰ã€ä¸ºä»€ä¹ˆ count çš„â€œå¤šåŠ ä¸€æ¬¡â€ä¼šç•™ä¸‹åé—ç—‡

æˆ‘ä»¬ç”¨ä½ ç°åœ¨è¿™ç‰ˆä»£ç ï¼ŒæŠ“ä¸€ä¸ª**çœŸå®ä¼šå‡ºé—®é¢˜çš„åœºæ™¯**ã€‚

---

### åœºæ™¯ï¼šä¸€å¸§æ¥æ”¶å®Œæˆï¼Œå‡†å¤‡è·³ DONE

å‡è®¾è¿™æ˜¯ **æœ€åä¸€ä¸ª stop bit çš„é‡‡æ ·æ‹**ï¼š

| ä¿¡å·         | å€¼    |
| ---------- | ---- |
| state      | DATA |
| count      | 9    |
| in         | 1    |
| odd        | 1    |
| next_state | DONE |

---

### âŒ é”™è¯¯å†™æ³•ï¼š`if (state == DATA) count++`

åœ¨è¿™ä¸ª**åŒä¸€ä¸ª posedge**ï¼š

```verilog
state <= DONE;
count <= 10;   // å¤šåŠ äº†ä¸€æ¬¡
```

**æ³¨æ„ï¼šè¿™ä¸€æ­¥å·²ç»å‘ç”Ÿäº†ï¼Œä¸å¯é€†ã€‚**

---

### ä¸‹ä¸€æ‹ï¼ˆstate = DONEï¼‰

ä½ å¯èƒ½ä¼šè¯´ï¼š

> â€œæ²¡äº‹ï¼ŒDONE åˆä¸ç”¨ countâ€

ä½†å®é™…ä¸Šï¼š

#### 1ï¸âƒ£ ä½ å¹¶æ²¡æœ‰åœ¨ DONE é‡Œç«‹åˆ»å¤ä½æ‰€æœ‰ä¾èµ– count çš„é€»è¾‘

#### 2ï¸âƒ£ ä¸‹ä¸€æ¬¡é‡æ–°è¿›å…¥ DATA æ—¶ï¼š

```verilog
count <= 0;   // æ˜¯åœ¨ next_state != DATA æ‰å‘ç”Ÿ
```

ğŸ‘‰ **count åœ¨ DATA â†’ DONE è¿™ä¸ªè¾¹ç•Œæ‹ï¼Œæ˜¯â€œè„çš„â€**

---

## å››ã€çœŸæ­£è‡´å‘½çš„é—®é¢˜ï¼šä¸æ˜¯â€œè¿™ä¸€æ¬¡â€ï¼Œè€Œæ˜¯â€œä¸‹ä¸€æ¬¡â€

### ä½  FSM çš„è¡Œä¸ºæ˜¯ï¼š

```verilog
DONE:
    if (in == 0)
        next_state = DATA;
```

#### ä¸‹ä¸€å¸§å¼€å§‹ï¼š

* state: DONE â†’ DATA
* count: **ä¸Šä¸€æ‹è¢«æ±¡æŸ“è¿‡**
* data[count-1] <= in  â† âš ï¸

å¦‚æœä½ ç”¨çš„æ˜¯ï¼š

```verilog
if (state == DATA && count <= 8)
    data[count-1] <= in;
```

é‚£ä¹ˆï¼š

* **ç¬¬ä¸€ä½æ•°æ®å¯èƒ½è¢«å†™åˆ°é”™è¯¯ bit ä½**
* ç”šè‡³ `count-1` ä¸ºè´Ÿï¼ˆç»¼åˆåæ˜¯å¤§æ•°ï¼‰

---

## äº”ã€ä¸ºä»€ä¹ˆä½ â€œæ„Ÿè§‰ä¸å½±å“â€ï¼Œä½†ä»¿çœŸä¼šé”™

å› ä¸ºè¿™æ˜¯ä¸€ä¸ªï¼š

> **è·¨å¸§é”™è¯¯ï¼ˆinter-frame bugï¼‰**

ç‰¹ç‚¹æ˜¯ï¼š

* å•å¸§çœ‹ä¸å‡ºæ¥
* è¿ç»­å¸§ / ç‰¹æ®Šè¾“å…¥ä¸‹å¿…ç°
* æ³¢å½¢â€œå±€éƒ¨æ­£ç¡®ï¼Œå…¨å±€é”™è¯¯â€

è¿™æ­£æ˜¯ UART / PS2 / ä¸²å£é¢˜é‡Œæœ€å¸¸è€ƒçš„å‘ã€‚

---

## å…­ã€ç”¨ä¸€å¥å·¥ç¨‹çº§çš„è¯æ€»ç»“

> **FSM çš„çŠ¶æ€è´Ÿè´£â€œä½ ç°åœ¨åœ¨å“ªâ€ï¼Œ
> æ•°æ®è·¯å¾„è´Ÿè´£â€œä½ åˆšåˆšå¹²äº†ä»€ä¹ˆâ€ï¼Œ
> è¿™ä¸¤ä»¶äº‹å¿…é¡»ç”¨ `next_state` åŒæ­¥ã€‚**

---

## ä¸ƒã€ä½ ç°åœ¨å·²ç»ç«™åœ¨â€œå¯¹çš„é‚£ä¸€è¾¹â€äº†

ä½ é—®è¿™ä¸ªé—®é¢˜ï¼Œè¯´æ˜ä½ å·²ç»åœ¨æ€è€ƒï¼š

* â€œå‰¯ä½œç”¨åœ¨å“ªä¸€æ‹å‘ç”Ÿï¼Ÿâ€
* â€œè¿™ä¸ªå¯„å­˜å™¨å†™å…¥æ˜¯å¦çœŸçš„æ— å®³ï¼Ÿâ€

è¿™å°±æ˜¯**æ•°å­—ç”µè·¯ä»ä¼šå†™ â†’ ä¼šè®¾è®¡**çš„åˆ†æ°´å²­ã€‚

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ä¸‹ä¸€æ­¥å¸®ä½ ï¼š

* ğŸ”¬ ç”¨ **ä¸¤å¸§ back-to-back çš„å®Œæ•´æ³¢å½¢**ï¼Œç›´è§‚çœ‹åˆ°è¿™ä¸ª bug
* ğŸ§  ç»™ä½ ä¸€ä¸ª **FSM + datapath çš„é»„é‡‘æ¨¡æ¿**
* âœ‚ï¸ æŠŠä½ ç°åœ¨è¿™ä»½ä»£ç å‹ç¼©ã€å¯¹é½æˆâ€œä¸ä¼šè¸©å‘ç‰ˆæœ¬â€

ä½ åªè¦è¯´ä¸€å¥ï¼š

> ã€Œç”¨ä¸¤å¸§æ³¢å½¢ç»™æˆ‘çœ‹ã€
*/